<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>URI routing &mdash; Nacelle Microframework 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Nacelle Microframework 0.1.0 documentation" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../index.html">Nacelle Microframework 0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="uri-routing">
<span id="guide-routing"></span><h1>URI routing<a class="headerlink" href="#uri-routing" title="Permalink to this headline">¶</a></h1>
<p><cite>URI routing</cite> is the process of taking the requested URI and deciding which
application handler will handle the current request. For this, we initialize
the <tt class="xref py py-class docutils literal"><span class="pre">WSGIApplication</span></tt> defining a list of <cite>routes</cite>: each <cite>route</cite>
analyses the current request and, if it matches certain criterias, returns
the handler and optional variables extracted from the URI.</p>
<p>webapp2 offers a powerful and extensible system to match and build URIs,
which is explained in details in this section.</p>
<div class="section" id="simple-routes">
<h2>Simple routes<a class="headerlink" href="#simple-routes" title="Permalink to this headline">¶</a></h2>
<p>The simplest form of URI route in webapp2 is a tuple <tt class="docutils literal"><span class="pre">(regex,</span> <span class="pre">handler)</span></tt>,
where <cite>regex</cite> is a regular expression to match the requested URI path and
<cite>handler</cite> is a callable to handle the request. This routing mechanism is
fully compatible with App Engine&#8217;s webapp framework.</p>
<p>This is how it works: a list of routes is registered in the
<a class="reference internal" href="app.html#guide-app"><em>WSGI application</em></a>. When the application receives a request,
it tries to match each one in order until one matches, and then call the
corresponding handler. Here, for example, we define three handlers and
register three routes that point to those handlers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">HomeHandler</span><span class="p">(</span><span class="n">webapp2</span><span class="o">.</span><span class="n">RequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;This is the HomeHandler.&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ProductListHandler</span><span class="p">(</span><span class="n">webapp2</span><span class="o">.</span><span class="n">RequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;This is the ProductListHandler.&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ProductHandler</span><span class="p">(</span><span class="n">webapp2</span><span class="o">.</span><span class="n">RequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">product_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">response</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;This is the ProductHandler. &#39;</span>
            <span class="s">&#39;The product id is </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">product_id</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">webapp2</span><span class="o">.</span><span class="n">WSGIApplication</span><span class="p">([</span>
    <span class="p">(</span><span class="s">r&#39;/&#39;</span><span class="p">,</span> <span class="n">HomeHandler</span><span class="p">),</span>
    <span class="p">(</span><span class="s">r&#39;/products&#39;</span><span class="p">,</span> <span class="n">ProductListHandler</span><span class="p">),</span>
    <span class="p">(</span><span class="s">r&#39;/products/(\d+)&#39;</span><span class="p">,</span> <span class="n">ProductHandler</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>When a request comes in, the application will match the request path to find
the corresponding handler. If no route matches, an <tt class="docutils literal"><span class="pre">HTTPException</span></tt> is raised
with status code 404, and the WSGI application can handle it accordingly (see
<a class="reference internal" href="exceptions.html#guide-exceptions"><em>Exception handling</em></a>).</p>
<p>The <cite>regex</cite> part is an ordinary regular expression (see the <tt class="xref py py-mod docutils literal"><span class="pre">re</span></tt>
module) that can define groups inside parentheses. The matched group values are
passed to the handler as positional arguments. In the example above, the last
route defines a group, so the handler will receive the matched value when the
route matches (one or more digits in this case).</p>
<p>The <cite>handler</cite> part is a callable as explained in <a class="reference internal" href="handlers.html#guide-handlers"><em>Request handlers</em></a>, and
can also be a string in dotted notation to be lazily imported when needed
(see explanation below in <a class="reference internal" href="#guide-routing-lazy-handlers"><em>Lazy Handlers</em></a>).</p>
<p>Simple routes are easy to use and enough for a lot of cases but don&#8217;t support
keyword arguments, URI building, domain and subdomain matching, automatic
redirection and other useful features. For this, webapp2 offers the extended
routing mechanism that we&#8217;ll see next.</p>
</div>
<div class="section" id="extended-routes">
<h2>Extended routes<a class="headerlink" href="#extended-routes" title="Permalink to this headline">¶</a></h2>
<p>webapp2 introduces a routing mechanism that extends the webapp model to provide
additional features:</p>
<ul class="simple">
<li><strong>URI building:</strong> the registered routes can be built when needed, avoiding
hardcoded URIs in the app code and templates. If you change the route
definition in a compatible way during development, all places that use that
route will continue to point to the correct URI. This is less error prone and
easier to maintain.</li>
<li><strong>Keyword arguments:</strong> handlers can receive keyword arguments from the
matched URIs. This is easier to use and also more maintanable than positional
arguments.</li>
<li><strong>Nested routes:</strong> routes can be extended to match more than the request
path. We will see below a route class that can also match domains and
subdomains.</li>
</ul>
<p>And several other features and benefits.</p>
<p>The concept is similar to the simple routes we saw before, but instead of a
tuple <tt class="docutils literal"><span class="pre">(regex,</span> <span class="pre">handler)</span></tt>, we define each route using the class
<tt class="xref py py-class docutils literal"><span class="pre">webapp2.Route</span></tt>. Let&#8217;s remake our previous routes using it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">webapp2</span><span class="o">.</span><span class="n">WSGIApplication</span><span class="p">([</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">r&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">HomeHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;home&#39;</span><span class="p">),</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">r&#39;/products&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">ProductListHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;product-list&#39;</span><span class="p">),</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">r&#39;/products/&lt;product_id:\d+&gt;&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">ProductHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;product&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>The first argument in the routes above is a
<a class="reference internal" href="#guide-routing-the-url-template"><em>URL template</em></a>, the <cite>handler</cite>
argument is the <a class="reference internal" href="handlers.html#guide-handlers"><em>request handler</em></a> to be used, and the
<cite>name</cite> argument third is a name used to
<a class="reference internal" href="#guide-routing-building-uris"><em>build a URI</em></a> for that route.</p>
<p>Check <tt class="xref py py-meth docutils literal"><span class="pre">webapp2.Route.__init__()</span></tt> in the API reference for the parameters
accepted by the <tt class="docutils literal"><span class="pre">Route</span></tt> constructor. We will explain some of them in details
below.</p>
<div class="section" id="the-url-template">
<span id="guide-routing-the-url-template"></span><h3>The URL template<a class="headerlink" href="#the-url-template" title="Permalink to this headline">¶</a></h3>
<p>The URL template defines the URL path to be matched. It can have regular
expressions for variables using the syntax <tt class="docutils literal"><span class="pre">&lt;name:regex&gt;</span></tt>; everything
outside of <tt class="docutils literal"><span class="pre">&lt;&gt;</span></tt> is not interpreted as a regular expression to be matched.
Both name and regex are optional, like in the examples below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="69%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&lt;name&gt;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">'/blog/&lt;year&gt;/&lt;month&gt;'</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">&lt;:regex&gt;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">'/blog/&lt;:\d{4}&gt;/&lt;:\d{2}&gt;'</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">&lt;name:regex&gt;</span></tt></td>
<td><tt class="docutils literal"><span class="pre">'/blog/&lt;year:\d{4}&gt;/&lt;month:\d{2}&gt;'</span></tt></td>
</tr>
</tbody>
</table>
<p>The same template can mix parts with name, regular expression or both.</p>
<p>The name, if defined, is used to build URLs for the route. When it is set,
the value of the matched regular expression is passed as keyword argument to
the handler. Otherwise it is passed as positional argument.</p>
<p>If only the name is set, it will match anything except a slash. So these
routes are equivalent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&lt;user_id&gt;/settings&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">SettingsHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;user-settings&#39;</span><span class="p">)</span>
<span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&lt;user_id:[^/]+&gt;/settings&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">SettingsHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;user-settings&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The handler only receives <tt class="docutils literal"><span class="pre">*args</span></tt> if no named variables are
set. Otherwise, the handler only receives <tt class="docutils literal"><span class="pre">**kwargs</span></tt>. This
allows you to set regular expressions that are not captured:
just mix named and unnamed variables and the handler will
only receive the named ones.</p>
</div>
</div>
<div class="section" id="lazy-handlers">
<span id="guide-routing-lazy-handlers"></span><h3>Lazy handlers<a class="headerlink" href="#lazy-handlers" title="Permalink to this headline">¶</a></h3>
<p>One additional feature compared to webapp is that the handler can also be
defined as a string in dotted notation to be lazily imported when needed.</p>
<p>This is useful to avoid loading all modules when the app is initialized: we
can define handlers in different modules without needing to import all of them
to initialize the app. This is not only convenient but also speeds up the
application startup.</p>
<p>The string must contain the package or module name and the name of the handler
(a class or function name). Our previous example could be rewritten using
strings instead of handler classes and splitting our handlers in two files,
<tt class="docutils literal"><span class="pre">handlers.py</span></tt> and <tt class="docutils literal"><span class="pre">products.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">webapp2</span><span class="o">.</span><span class="n">WSGIApplication</span><span class="p">([</span>
    <span class="p">(</span><span class="s">r&#39;/&#39;</span><span class="p">,</span> <span class="s">&#39;handlers.HomeHandler&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">r&#39;/products&#39;</span><span class="p">,</span> <span class="s">&#39;products.ProductListHandler&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">r&#39;/products/(\d+)&#39;</span><span class="p">,</span> <span class="s">&#39;products.ProductHandler&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>In the first time that one of these routes matches, the handlers will be
automatically imported by the routing system.</p>
</div>
<div class="section" id="custom-methods">
<span id="guide-routing-custom-methods"></span><h3>Custom methods<a class="headerlink" href="#custom-methods" title="Permalink to this headline">¶</a></h3>
<p>A parameter <tt class="docutils literal"><span class="pre">handler_method</span></tt> can define the method of the handler that will
be called, if handler is a class. If not defined, the default behavior is to
translate the HTTP method to a handler method, as explained in
<a class="reference internal" href="handlers.html#guide-handlers"><em>Request handlers</em></a>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">r&#39;/products&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="s">&#39;handlers.ProductsHandler&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;products-list&#39;</span><span class="p">,</span> <span class="n">handler_method</span><span class="o">=</span><span class="s">&#39;list_products&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, the handler method can be defined in the handler string,
separated by a colon. This is equivalent to the previous example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">r&#39;/products&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="s">&#39;handlers.ProductsHandler:list_products&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;products-list&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="restricting-http-methods">
<span id="guide-routing-restricting-http-methods"></span><h3>Restricting HTTP methods<a class="headerlink" href="#restricting-http-methods" title="Permalink to this headline">¶</a></h3>
<p>If needed, the route can define a sequence of allowed HTTP methods. Only if the
request method is in that list or tuple the route will match. If the method is
not allowed, an <tt class="docutils literal"><span class="pre">HTTPMethodNotAllowed</span></tt> exception is raised with status code
405. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">r&#39;/products&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="s">&#39;handlers.ProductsHandler&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;products-list&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;GET&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>This is useful when using functions as handlers, or alternative handlers that
don&#8217;t translate the HTTP method to the handler method like the default
<tt class="xref py py-class docutils literal"><span class="pre">webapp2.RequestHandler</span></tt> does.</p>
</div>
<div class="section" id="restricting-uri-schemes">
<span id="guide-routing-restricting-uri-schemes"></span><h3>Restricting URI schemes<a class="headerlink" href="#restricting-uri-schemes" title="Permalink to this headline">¶</a></h3>
<p>Like with HTTP methods, you can specify the URI schemes allowed for a route,
if needed. This is useful if some URIs must be accessed using &#8216;http&#8217; or &#8216;https&#8217;
only. For this, set the <tt class="docutils literal"><span class="pre">schemes</span></tt> parameter when defining a route:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">r&#39;/products&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="s">&#39;handlers.ProductsHandler&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;products-list&#39;</span><span class="p">,</span> <span class="n">schemes</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;https&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The above route will only match if the URI scheme is &#8216;https&#8217;.</p>
</div>
</div>
<div class="section" id="domain-and-subdomain-routing">
<span id="guide-routing-domain-and-subdomain-routing"></span><h2>Domain and subdomain routing<a class="headerlink" href="#domain-and-subdomain-routing" title="Permalink to this headline">¶</a></h2>
<p>The routing system can also handle domain and subdomain matching. This is done
using a special route class provided in the <tt class="xref py py-mod docutils literal"><span class="pre">webapp2_extras.routes</span></tt>
module: the <tt class="xref py py-class docutils literal"><span class="pre">webapp2_extras.routes.DomainRoute</span></tt>. It is initialized with
a pattern to match the current server name and a list of nested
<tt class="xref py py-class docutils literal"><span class="pre">webapp2.Route</span></tt> instances that will only be tested if the domain or
subdomain matches.</p>
<p>For example, to restrict routes to a subdomain of the appspot domain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">webapp2</span>
<span class="kn">from</span> <span class="nn">webapp2_extras</span> <span class="kn">import</span> <span class="n">routes</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">webapp2</span><span class="o">.</span><span class="n">WSGIApplication</span><span class="p">([</span>
    <span class="n">routes</span><span class="o">.</span><span class="n">DomainRoute</span><span class="p">(</span><span class="s">&#39;&lt;subdomain&gt;.app-id.appspot.com&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">SubdomainHomeHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;subdomain-home&#39;</span><span class="p">),</span>
    <span class="p">]),</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">HomeHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;home&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>In the example above, we define a template <tt class="docutils literal"><span class="pre">'&lt;subdomain&gt;.app-id.appspot.com'</span></tt>
for the domain matching. When a request comes in, only if the request server
name matches that pattern, the nested route will be tested. Otherwise the
routing system will test the next route until one matches. So the first route
with path <tt class="docutils literal"><span class="pre">/</span></tt> will only match when a subdomain of the <tt class="docutils literal"><span class="pre">app-id.appspot.com</span></tt>
domain is accessed. Otherwise the second route with path <tt class="docutils literal"><span class="pre">/</span></tt> will be used.</p>
<p>The template follows the same syntax used by <tt class="xref py py-class docutils literal"><span class="pre">webapp2.Route</span></tt> and
must define named groups if any value must be added to the match results.
In the example above, an extra <cite>subdomain</cite> keyword is passed to the handler,
but if the regex didn&#8217;t define any named groups, nothing would be added.</p>
<div class="section" id="matching-only-www-or-anything-except-www">
<h3>Matching only www, or anything except www<a class="headerlink" href="#matching-only-www-or-anything-except-www" title="Permalink to this headline">¶</a></h3>
<p>A common need is to set some routes for the main subdomain (<tt class="docutils literal"><span class="pre">www</span></tt>) and
different routes for other submains. The webapp2 routing system can handle
this easily.</p>
<p>To match only the <tt class="docutils literal"><span class="pre">www</span></tt> subdomain, simple set the domain template to a fixed
value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">routes</span><span class="o">.</span><span class="n">DomainRoute</span><span class="p">(</span><span class="s">&#39;www.mydomain.com&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">HomeHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;home&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>To match any subdomain except the <tt class="docutils literal"><span class="pre">www</span></tt> subdomain, set a regular expression
that excludes <tt class="docutils literal"><span class="pre">www</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">routes</span><span class="o">.</span><span class="n">DomainRoute</span><span class="p">(</span><span class="s">r&#39;&lt;subdomain:(?!www\.)[^.]+&gt;.mydomain.com&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">HomeHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;home&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Any subdomain that matches and is not <tt class="docutils literal"><span class="pre">www</span></tt> will be passed as a parameter
<tt class="docutils literal"><span class="pre">subdomain</span></tt> to the handler.</p>
<p>Similarly, you can restrict matches to the main <tt class="docutils literal"><span class="pre">appspot</span></tt> domain <strong>or</strong>
a <tt class="docutils literal"><span class="pre">www</span></tt> domain from a custom domain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">routes</span><span class="o">.</span><span class="n">DomainRoute</span><span class="p">(</span><span class="s">r&#39;&lt;:(app-id\.appspot\.com|www\.mydomain\.com)&gt;&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">HomeHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;home&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>And then have a route that matches subdomains of the main <tt class="docutils literal"><span class="pre">appspot</span></tt> domain
<strong>or</strong> from a custom domain, except <tt class="docutils literal"><span class="pre">www</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">routes</span><span class="o">.</span><span class="n">DomainRoute</span><span class="p">(</span><span class="s">r&#39;&lt;subdomain:(?!www)[^.]+&gt;.&lt;:(app-id\.appspot\.com|mydomain\.com)&gt;&#39;</span><span class="p">,</span> <span class="p">[</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">HomeHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;home&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="path-prefix-routes">
<span id="guide-routing-path-prefix-routes"></span><h2>Path prefix routes<a class="headerlink" href="#path-prefix-routes" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref py py-mod docutils literal"><span class="pre">webapp2_extras.routes</span></tt> provides a class to wrap routes that start
with a common path: the <tt class="xref py py-mod docutils literal"><span class="pre">webapp2_extras.routes.PathPrefixRoute</span></tt>.
The intention is to avoid repetition when defining routes.</p>
<p>For example, imagine we have these routes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">WSGIApplication</span><span class="p">([</span>
    <span class="n">Route</span><span class="p">(</span><span class="s">&#39;/users/&lt;user:\w+&gt;/&#39;</span><span class="p">,</span> <span class="n">UserOverviewHandler</span><span class="p">,</span> <span class="s">&#39;user-overview&#39;</span><span class="p">),</span>
    <span class="n">Route</span><span class="p">(</span><span class="s">&#39;/users/&lt;user:\w+&gt;/profile&#39;</span><span class="p">,</span> <span class="n">UserProfileHandler</span><span class="p">,</span> <span class="s">&#39;user-profile&#39;</span><span class="p">),</span>
    <span class="n">Route</span><span class="p">(</span><span class="s">&#39;/users/&lt;user:\w+&gt;/projects&#39;</span><span class="p">,</span> <span class="n">UserProjectsHandler</span><span class="p">,</span> <span class="s">&#39;user-projects&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>We could refactor them to reuse the common path prefix:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">webapp2</span>
<span class="kn">from</span> <span class="nn">webapp2_extras</span> <span class="kn">import</span> <span class="n">routes</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">WSGIApplication</span><span class="p">([</span>
    <span class="n">routes</span><span class="o">.</span><span class="n">PathPrefixRoute</span><span class="p">(</span><span class="s">&#39;/users/&lt;user:\w+&gt;&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">UserOverviewHandler</span><span class="p">,</span> <span class="s">&#39;user-overview&#39;</span><span class="p">),</span>
        <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/profile&#39;</span><span class="p">,</span> <span class="n">UserProfileHandler</span><span class="p">,</span> <span class="s">&#39;user-profile&#39;</span><span class="p">),</span>
        <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/projects&#39;</span><span class="p">,</span> <span class="n">UserProjectsHandler</span><span class="p">,</span> <span class="s">&#39;user-projects&#39;</span><span class="p">),</span>
    <span class="p">]),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>This is not only convenient, but also performs better: the nested routes
will only be tested if the path prefix matches.</p>
</div>
<div class="section" id="other-prefix-routes">
<span id="guide-routing-other-prefix-routes"></span><h2>Other prefix routes<a class="headerlink" href="#other-prefix-routes" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref py py-mod docutils literal"><span class="pre">webapp2_extras.routes</span></tt> has other convenience classes that accept
nested routes with a common attribute prefix:</p>
<ul class="simple">
<li><tt class="xref py py-mod docutils literal"><span class="pre">webapp2_extras.routes.HandlerPrefixRoute</span></tt>: receives a handler module
prefix in dotted notation and a list of routes that use that module.</li>
<li><tt class="xref py py-mod docutils literal"><span class="pre">webapp2_extras.routes.NamePrefixRoute</span></tt>: receives a handler name
prefix and a list of routes that start with that name.</li>
</ul>
</div>
<div class="section" id="building-uris">
<span id="guide-routing-building-uris"></span><h2>Building URIs<a class="headerlink" href="#building-uris" title="Permalink to this headline">¶</a></h2>
<p>Because our routes have a <tt class="docutils literal"><span class="pre">name</span></tt>, we can use the routing system to build
URIs whenever we need to reference those resources inside the application.
This is done using the function <tt class="xref py py-func docutils literal"><span class="pre">webapp2.uri_for()</span></tt> or the method
<tt class="xref py py-meth docutils literal"><span class="pre">webapp2.RequestHandler.uri_for()</span></tt> inside a handler, or calling
<tt class="xref py py-meth docutils literal"><span class="pre">webapp2.Router.build()</span></tt> directly (a <tt class="docutils literal"><span class="pre">Router</span></tt> instance is set as an
attribute <tt class="docutils literal"><span class="pre">router</span></tt> in the WSGI application).</p>
<p>For example, if you have these routes defined for the application:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">app</span> <span class="o">=</span> <span class="n">webapp2</span><span class="o">.</span><span class="n">WSGIApplication</span><span class="p">([</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="s">&#39;handlers.HomeHandler&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;home&#39;</span><span class="p">),</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/wiki&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">WikiHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;wiki&#39;</span><span class="p">),</span>
    <span class="n">webapp2</span><span class="o">.</span><span class="n">Route</span><span class="p">(</span><span class="s">&#39;/wiki/&lt;page&gt;&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">WikiHandler</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;wiki-page&#39;</span><span class="p">),</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Here are some examples of how to generate URIs for them:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># /</span>
<span class="n">uri</span> <span class="o">=</span> <span class="n">uri_for</span><span class="p">(</span><span class="s">&#39;home&#39;</span><span class="p">)</span>
<span class="c"># http://localhost:8080/</span>
<span class="n">uri</span> <span class="o">=</span> <span class="n">uri_for</span><span class="p">(</span><span class="s">&#39;home&#39;</span><span class="p">,</span> <span class="n">_full</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># /wiki</span>
<span class="n">uri</span> <span class="o">=</span> <span class="n">uri_for</span><span class="p">(</span><span class="s">&#39;wiki&#39;</span><span class="p">)</span>
<span class="c"># http://localhost:8080/wiki</span>
<span class="n">uri</span> <span class="o">=</span> <span class="n">uri_for</span><span class="p">(</span><span class="s">&#39;wiki&#39;</span><span class="p">,</span> <span class="n">_full</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c"># http://localhost:8080/wiki#my-heading</span>
<span class="n">uri</span> <span class="o">=</span> <span class="n">uri_for</span><span class="p">(</span><span class="s">&#39;wiki&#39;</span><span class="p">,</span> <span class="n">_full</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">_fragment</span><span class="o">=</span><span class="s">&#39;my-heading&#39;</span><span class="p">)</span>
<span class="c"># /wiki/my-first-page</span>
<span class="n">uri</span> <span class="o">=</span> <span class="n">uri_for</span><span class="p">(</span><span class="s">&#39;wiki-page&#39;</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="s">&#39;my-first-page&#39;</span><span class="p">)</span>
<span class="c"># /wiki/my-first-page?format=atom</span>
<span class="n">uri</span> <span class="o">=</span> <span class="n">uri_for</span><span class="p">(</span><span class="s">&#39;wiki-page&#39;</span><span class="p">,</span> <span class="n">page</span><span class="o">=</span><span class="s">&#39;my-first-page&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;atom&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Variables are passed as positional or keyword arguments and are required if
the route defines them. Keyword arguments that are not present in the route
are added to the URI as a query string.</p>
<p>Also, when calling <tt class="docutils literal"><span class="pre">uri_for()</span></tt>, a few keywords have special meaning:</p>
<dl class="docutils">
<dt>_full</dt>
<dd>If True, builds an absolute URI.</dd>
<dt>_scheme</dt>
<dd>URI scheme, e.g., <cite>http</cite> or <cite>https</cite>. If defined, an absolute URI is always
returned.</dd>
<dt>_netloc</dt>
<dd>Network location, e.g., <cite>www.google.com</cite>. If defined, an absolute URI is
always returned.</dd>
<dt>_fragment</dt>
<dd>If set, appends a fragment (or &#8220;anchor&#8221;) to the generated URI.</dd>
</dl>
<p>Check <tt class="xref py py-meth docutils literal"><span class="pre">webapp2.Router.build()</span></tt> in the API reference for a complete
explanation of the parameters used to build URIs.</p>
</div>
<div class="section" id="routing-attributes-in-the-request-object">
<h2>Routing attributes in the request object<a class="headerlink" href="#routing-attributes-in-the-request-object" title="Permalink to this headline">¶</a></h2>
<p>The parameters from the matched route are set as attributes of the request
object when a route matches. They are <tt class="docutils literal"><span class="pre">request.route_args</span></tt>, for positional
arguments, and <tt class="docutils literal"><span class="pre">request.route_kwargs</span></tt>, for keyword arguments.</p>
<p>The matched route object is also available as <tt class="docutils literal"><span class="pre">request.route</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">URI routing</a><ul>
<li><a class="reference internal" href="#simple-routes">Simple routes</a></li>
<li><a class="reference internal" href="#extended-routes">Extended routes</a><ul>
<li><a class="reference internal" href="#the-url-template">The URL template</a></li>
<li><a class="reference internal" href="#lazy-handlers">Lazy handlers</a></li>
<li><a class="reference internal" href="#custom-methods">Custom methods</a></li>
<li><a class="reference internal" href="#restricting-http-methods">Restricting HTTP methods</a></li>
<li><a class="reference internal" href="#restricting-uri-schemes">Restricting URI schemes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#domain-and-subdomain-routing">Domain and subdomain routing</a><ul>
<li><a class="reference internal" href="#matching-only-www-or-anything-except-www">Matching only www, or anything except www</a></li>
</ul>
</li>
<li><a class="reference internal" href="#path-prefix-routes">Path prefix routes</a></li>
<li><a class="reference internal" href="#other-prefix-routes">Other prefix routes</a></li>
<li><a class="reference internal" href="#building-uris">Building URIs</a></li>
<li><a class="reference internal" href="#routing-attributes-in-the-request-object">Routing attributes in the request object</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/guide/routing.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../index.html">Nacelle Microframework 0.1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Patrick Carey.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>